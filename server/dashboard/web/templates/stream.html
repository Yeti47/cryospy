{{define "content"}}
<div class="page-header">
    <h2>Live Stream - {{.Client.ID}}</h2>
    <div class="stream-controls">
        <a href="/stream" class="btn btn-secondary">Back to Selection</a>
    </div>
</div>

<div class="stream-container">
    <video id="videoPlayer" controls muted playsinline>
        <p>Your browser does not support HLS video streaming.</p>
    </video>
    
    <div class="stream-info">
        <div class="info-item">
            <strong>Client:</strong> {{.Client.ID}}
        </div>
        <div class="info-item">
            <strong>Start Time:</strong> <span id="startTime">{{.StartTime}}</span>
        </div>
        <div class="info-item">
            <strong>Reference Time:</strong> <span id="refTime">{{.RefTime}}</span>
        </div>
        <div class="info-item">
            <strong>Status:</strong> <span id="streamStatus">Initializing...</span>
        </div>
        <div class="info-item">
            <strong>Footage Begins:</strong> <span id="streamStart">-</span>
        </div>
        <div class="info-item">
            <strong>Current Clip:</strong> <span id="currentClip">-</span>
        </div>
        <div class="info-item">
            <strong>Current Segment Motion:</strong> <span id="motionStatus">-</span>
        </div>
        <div class="info-item">
            <strong>Footage Contains Motion:</strong> 
            <span id="overallMotion" class="motion-badge-clickable" style="cursor: pointer;">-</span>
        </div>
        <div id="motionDetails" class="motion-details-panel" style="display: none;">
            <strong>Motion Detection Timeline:</strong>
            <div id="motionTimeline" class="motion-timeline">
                <!-- Motion events will be populated here -->
            </div>
        </div>
    </div>
</div>

<!-- HLS.js Library -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<script>
const video = document.getElementById('videoPlayer');
const statusEl = document.getElementById('streamStatus');

const clientId = '{{.Client.ID}}';
const startTime = '{{.StartTime}}';
const refTime = '{{.RefTime}}';

// Construct playlist URL
const playlistUrl = `/stream/${clientId}/playlist.m3u8?startTime=${encodeURIComponent(startTime)}&refTime=${encodeURIComponent(refTime)}`;

let hls;
let playlistSegments = []; // Store parsed segment metadata
let currentSegmentIndex = -1;
let retryCount = 0;
let maxRetries = 5;
let retryDelay = 2000; // Start with 2 seconds

// Parse playlist to extract segment metadata
function parsePlaylistMetadata(playlistText) {
    const lines = playlistText.split('\n');
    const segments = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('#EXTINF:')) {
            // Extract metadata from EXTINF line
            const metadataMatch = line.match(/#EXTINF:[^,]*,(.*)$/);
            if (metadataMatch && metadataMatch[1]) {
                try {
                    const metadata = JSON.parse(metadataMatch[1]);
                    // Get the segment URL from the next line
                    const urlLine = lines[i + 1];
                    if (urlLine && !urlLine.startsWith('#')) {
                        segments.push({
                            url: urlLine.trim(),
                            title: metadata.title || 'Unknown',
                            recordedAt: new Date(metadata.recorded_at),
                            hasMotion: metadata.motion || false,
                            index: segments.length
                        });
                    }
                } catch (e) {
                    console.warn('Failed to parse segment metadata:', metadataMatch[1]);
                }
            }
        }
    }
    
    return segments;
}

// Update stream info display
function updateStreamInfo() {
    const streamStartEl = document.getElementById('streamStart');
    const currentClipEl = document.getElementById('currentClip');
    const motionStatusEl = document.getElementById('motionStatus');
    const overallMotionEl = document.getElementById('overallMotion');
    const motionDetailsToggle = document.getElementById('motionDetailsToggle');
    
    if (playlistSegments.length > 0) {
        // Show the earliest recording time as when footage begins
        const earliestSegment = playlistSegments[0];
        streamStartEl.textContent = earliestSegment.recordedAt.toLocaleString();
        
        // Calculate overall motion status for all loaded footage
        const hasAnyMotion = playlistSegments.some(segment => segment.hasMotion);
        const motionSegmentCount = playlistSegments.filter(segment => segment.hasMotion).length;
        
        if (hasAnyMotion) {
            overallMotionEl.textContent = `Yes (${motionSegmentCount}/${playlistSegments.length} segments) ▼`;
            overallMotionEl.className = 'motion motion-badge-clickable';
            updateMotionDetails();
        } else {
            overallMotionEl.textContent = 'No motion detected';
            overallMotionEl.className = 'no-motion';
        }
        
        // Update current clip info if we have a current segment
        if (currentSegmentIndex >= 0 && currentSegmentIndex < playlistSegments.length) {
            const currentSegment = playlistSegments[currentSegmentIndex];
            currentClipEl.textContent = `${currentSegment.title} (${currentSegment.recordedAt.toLocaleString()})`;
            motionStatusEl.textContent = currentSegment.hasMotion ? 'Yes' : 'No';
            motionStatusEl.className = currentSegment.hasMotion ? 'motion' : 'no-motion';
        }
    } else {
        // No segments available - show the no segments message
        showNoSegmentsMessage();
    }
}

// Update motion detection details
function updateMotionDetails() {
    const motionTimeline = document.getElementById('motionTimeline');
    const motionSegments = playlistSegments.filter(segment => segment.hasMotion);
    
    if (motionSegments.length === 0) {
        motionTimeline.innerHTML = '<p class="no-motion-events">No motion events found in loaded footage.</p>';
        return;
    }
    
    let html = '<div class="motion-events">';
    motionSegments.forEach((segment, index) => {
        const recordingTime = segment.recordedAt.toLocaleString();
        const isCurrentSegment = currentSegmentIndex >= 0 && 
            playlistSegments[currentSegmentIndex] && 
            playlistSegments[currentSegmentIndex].url === segment.url;
        
        // Find the original index of this segment in the full playlist
        const originalIndex = playlistSegments.findIndex(s => s.url === segment.url);
        const jumpTime = originalIndex * 30; // Calculate playback time (assuming 30s segments)
        
        html += `
            <div class="motion-event ${isCurrentSegment ? 'current-segment' : ''}" onclick="jumpToSegment(${jumpTime})" style="cursor: pointer;">
                <div class="motion-event-header">
                    <span class="motion-event-index">#${index + 1}</span>
                    <span class="motion-event-time">${recordingTime}</span>
                    ${isCurrentSegment ? '<span class="current-indicator">Currently Playing</span>' : ''}
                </div>
                <div class="motion-event-title">${segment.title}</div>
                <div class="motion-event-action">Click to jump to this segment</div>
            </div>
        `;
    });
    html += '</div>';
    
    motionTimeline.innerHTML = html;
}

// Jump to a specific segment in the video player
function jumpToSegment(timeInSeconds) {
    if (video && !isNaN(timeInSeconds) && timeInSeconds >= 0) {
        video.currentTime = timeInSeconds;
        
        // If the video is paused, start playing after jumping
        if (video.paused) {
            video.play().catch(err => {
                console.warn('Could not auto-play after jumping:', err);
            });
        }
        
        // Update status to show we're seeking
        statusEl.textContent = 'Seeking...';
        
        // The timeupdate event will automatically update the current segment index
        // and refresh the motion details to show the new current segment
    }
}

// Show helpful message when no segments are available
function showNoSegmentsMessage() {
    const streamStartEl = document.getElementById('streamStart');
    const currentClipEl = document.getElementById('currentClip');
    const motionStatusEl = document.getElementById('motionStatus');
    const overallMotionEl = document.getElementById('overallMotion');
    
    streamStartEl.textContent = 'No footage available';
    currentClipEl.textContent = 'No video segments found for the selected time range';
    motionStatusEl.textContent = 'N/A';
    overallMotionEl.textContent = 'No data available';
    
    // Hide motion details if visible
    const motionDetails = document.getElementById('motionDetails');
    motionDetails.style.display = 'none';
}

// Find current segment based on video current time
function updateCurrentSegment() {
    if (!video || !playlistSegments.length) return;
    
    const currentTime = video.currentTime;
    let segmentTime = 0;
    let newIndex = -1;
    
    // Calculate which segment should be playing based on cumulative duration
    for (let i = 0; i < playlistSegments.length; i++) {
        // Assume each segment is roughly the same duration (we could parse this from EXTINF if needed)
        const segmentDuration = 30; // Default duration, could be made more precise
        if (currentTime >= segmentTime && currentTime < segmentTime + segmentDuration) {
            newIndex = i;
            break;
        }
        segmentTime += segmentDuration;
    }
    
    if (newIndex !== currentSegmentIndex) {
        currentSegmentIndex = newIndex;
        updateStreamInfo();
        // Update motion details if the panel is visible and motion events exist
        const motionDetails = document.getElementById('motionDetails');
        if (motionDetails.style.display !== 'none' && playlistSegments.some(s => s.hasMotion)) {
            updateMotionDetails();
        }
    }
}

function initializePlayer() {
    if (Hls.isSupported()) {
        hls = new Hls({
            debug: false,
            enableWorker: true,
            liveSyncDurationCount: 3,
            liveMaxLatencyDurationCount: 10,
            maxBufferLength: 30,
            maxMaxBufferLength: 600,
            maxBufferSize: 60 * 1000 * 1000, // 60MB
            maxBufferHole: 0.5,
            lowLatencyMode: true,
            backBufferLength: 90,
            // Retry and loading configuration to prevent flooding
            manifestLoadingTimeOut: 10000, // 10 seconds timeout
            manifestLoadingMaxRetry: 3, // Limit manifest retries
            manifestLoadingRetryDelay: 2000, // 2 second delay between retries
            levelLoadingTimeOut: 10000,
            levelLoadingMaxRetry: 2, // Limit level loading retries
            levelLoadingRetryDelay: 2000,
            fragLoadingTimeOut: 20000,
            fragLoadingMaxRetry: 3,
            fragLoadingRetryDelay: 1000,
            // Custom loader to ensure proper relative URL resolution
            loader: Hls.DefaultConfig.loader
        });

        hls.loadSource(playlistUrl);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, function() {
            statusEl.textContent = 'Ready to play';
            retryCount = 0; // Reset retry count on successful load
            statusEl.style.color = ''; // Reset error color
            
            // Fetch and parse the playlist to extract metadata
            fetch(playlistUrl)
                .then(response => response.text())
                .then(playlistText => {
                    playlistSegments = parsePlaylistMetadata(playlistText);
                    updateStreamInfo();
                    
                    // If we successfully parsed the playlist but found no segments,
                    // it means the time range has no footage
                    if (playlistSegments.length === 0) {
                        console.log('Playlist loaded successfully but contains no segments');
                        statusEl.textContent = 'No footage available for this time range';
                        statusEl.style.color = 'var(--error-color)';
                    }
                })
                .catch(err => {
                    console.warn('Failed to fetch playlist for metadata:', err);
                });
        });

        hls.on(Hls.Events.ERROR, function(event, data) {
            console.error('HLS Error:', data);
            
            if (data.fatal) {
                switch (data.type) {
                    case Hls.ErrorTypes.NETWORK_ERROR:
                        if (data.details === 'levelEmptyError' || data.details === 'levelParsingError') {
                            statusEl.textContent = 'No video segments available for this time range';
                            
                            // Implement exponential backoff to prevent flooding
                            if (retryCount < maxRetries) {
                                retryCount++;
                                const currentDelay = retryDelay * Math.pow(2, retryCount - 1);
                                statusEl.textContent = `No segments available - retrying in ${currentDelay/1000}s (${retryCount}/${maxRetries})`;
                                
                                setTimeout(() => {
                                    console.log(`Retry attempt ${retryCount}/${maxRetries} after ${currentDelay}ms`);
                                    hls.startLoad();
                                }, currentDelay);
                            } else {
                                statusEl.textContent = 'No video segments found - maximum retries reached';
                                statusEl.style.color = 'var(--error-color)';
                                showNoSegmentsMessage();
                                console.error('Maximum retry attempts reached. Stopping further requests.');
                                return; // Stop retrying
                            }
                        } else {
                            statusEl.textContent = 'Network error - retrying...';
                            hls.startLoad();
                        }
                        break;
                    case Hls.ErrorTypes.MEDIA_ERROR:
                        statusEl.textContent = 'Media error - recovering...';
                        hls.recoverMediaError();
                        break;
                    default:
                        statusEl.textContent = 'Fatal error - cannot recover';
                        hls.destroy();
                        break;
                }
            } else {
                // Non-fatal errors - just log them
                console.warn('Non-fatal HLS error:', data.details, data);
            }
        });

        hls.on(Hls.Events.FRAG_LOADED, function() {
            if (statusEl.textContent === 'Loading...' || statusEl.textContent === 'Initializing...') {
                statusEl.textContent = 'Streaming';
            }
        });

    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (Safari)
        video.src = playlistUrl;
        statusEl.textContent = 'Ready to play (native)';
    } else {
        statusEl.textContent = 'HLS not supported in this browser';
        console.error('HLS is not supported');
    }
}

// Video event listeners
video.addEventListener('loadstart', () => statusEl.textContent = 'Loading...');
video.addEventListener('waiting', () => statusEl.textContent = 'Buffering...');
video.addEventListener('playing', () => statusEl.textContent = 'Playing');
video.addEventListener('pause', () => statusEl.textContent = 'Paused');
video.addEventListener('ended', () => statusEl.textContent = 'Ended');

// Track current segment during playback
video.addEventListener('timeupdate', updateCurrentSegment);

// Initialize the player when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializePlayer();
    
    // Set up motion details toggle - make the overall motion badge clickable
    const overallMotionEl = document.getElementById('overallMotion');
    const motionDetails = document.getElementById('motionDetails');
    
    overallMotionEl.addEventListener('click', function() {
        // Only toggle if there's motion data to show
        if (!overallMotionEl.classList.contains('motion-badge-clickable')) {
            return;
        }
        
        const isVisible = motionDetails.style.display !== 'none';
        if (isVisible) {
            motionDetails.style.display = 'none';
            // Change arrow to indicate expandable
            overallMotionEl.textContent = overallMotionEl.textContent.replace('▲', '▼');
        } else {
            motionDetails.style.display = 'block';
            // Change arrow to indicate collapsible
            overallMotionEl.textContent = overallMotionEl.textContent.replace('▼', '▲');
            updateMotionDetails();
        }
    });
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (hls) {
        hls.destroy();
    }
});

// Format timestamps for display
function formatTimestamp(isoString) {
    return new Date(isoString).toLocaleString();
}

document.getElementById('startTime').textContent = formatTimestamp('{{.StartTime}}');
document.getElementById('refTime').textContent = formatTimestamp('{{.RefTime}}');
</script>
{{end}}
