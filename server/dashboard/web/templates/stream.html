{{define "content"}}
<div class="page-header">
    <h2>Live Stream - {{.Client.ID}}</h2>
    <div class="stream-controls">
        <a href="/stream" class="btn btn-secondary">Back to Selection</a>
    </div>
</div>

<div class="stream-container">
    <video id="videoPlayer" controls muted playsinline>
        <p>Your browser does not support HLS video streaming.</p>
    </video>
    
    <div class="stream-info">
        <div class="info-item">
            <strong>Client:</strong> {{.Client.ID}}
        </div>
        <div class="info-item">
            <strong>Start Time:</strong> <span id="startTime">{{.StartTime}}</span>
        </div>
        <div class="info-item">
            <strong>Reference Time:</strong> <span id="refTime">{{.RefTime}}</span>
        </div>
        <div class="info-item">
            <strong>Status:</strong> <span id="streamStatus">Initializing...</span>
        </div>
        <div class="info-item">
            <strong>Footage Begins:</strong> <span id="streamStart">-</span>
        </div>
        <div class="info-item">
            <strong>Current Clip:</strong> <span id="currentClip">-</span>
        </div>
        <div class="info-item">
            <strong>Current Segment Motion:</strong> <span id="motionStatus">-</span>
        </div>
        <div class="info-item">
            <strong>Footage Contains Motion:</strong> <span id="overallMotion">-</span>
        </div>
    </div>
</div>

<!-- HLS.js Library -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

<script>
const video = document.getElementById('videoPlayer');
const statusEl = document.getElementById('streamStatus');

const clientId = '{{.Client.ID}}';
const startTime = '{{.StartTime}}';
const refTime = '{{.RefTime}}';

// Construct playlist URL
const playlistUrl = `/stream/${clientId}/playlist.m3u8?startTime=${encodeURIComponent(startTime)}&refTime=${encodeURIComponent(refTime)}`;

let hls;
let playlistSegments = []; // Store parsed segment metadata
let currentSegmentIndex = -1;

// Parse playlist to extract segment metadata
function parsePlaylistMetadata(playlistText) {
    const lines = playlistText.split('\n');
    const segments = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('#EXTINF:')) {
            // Extract metadata from EXTINF line
            const metadataMatch = line.match(/#EXTINF:[^,]*,(.*)$/);
            if (metadataMatch && metadataMatch[1]) {
                try {
                    const metadata = JSON.parse(metadataMatch[1]);
                    // Get the segment URL from the next line
                    const urlLine = lines[i + 1];
                    if (urlLine && !urlLine.startsWith('#')) {
                        segments.push({
                            url: urlLine.trim(),
                            title: metadata.title || 'Unknown',
                            recordedAt: new Date(metadata.recorded_at),
                            hasMotion: metadata.motion || false,
                            index: segments.length
                        });
                    }
                } catch (e) {
                    console.warn('Failed to parse segment metadata:', metadataMatch[1]);
                }
            }
        }
    }
    
    return segments;
}

// Update stream info display
function updateStreamInfo() {
    const streamStartEl = document.getElementById('streamStart');
    const currentClipEl = document.getElementById('currentClip');
    const motionStatusEl = document.getElementById('motionStatus');
    const overallMotionEl = document.getElementById('overallMotion');
    
    if (playlistSegments.length > 0) {
        // Show the earliest recording time as when footage begins
        const earliestSegment = playlistSegments[0];
        streamStartEl.textContent = earliestSegment.recordedAt.toLocaleString();
        
        // Calculate overall motion status for all loaded footage
        const hasAnyMotion = playlistSegments.some(segment => segment.hasMotion);
        const motionSegmentCount = playlistSegments.filter(segment => segment.hasMotion).length;
        
        if (hasAnyMotion) {
            overallMotionEl.textContent = `Yes (${motionSegmentCount}/${playlistSegments.length} segments)`;
            overallMotionEl.className = 'motion';
        } else {
            overallMotionEl.textContent = 'No motion detected';
            overallMotionEl.className = 'no-motion';
        }
        
        // Update current clip info if we have a current segment
        if (currentSegmentIndex >= 0 && currentSegmentIndex < playlistSegments.length) {
            const currentSegment = playlistSegments[currentSegmentIndex];
            currentClipEl.textContent = `${currentSegment.title} (${currentSegment.recordedAt.toLocaleString()})`;
            motionStatusEl.textContent = currentSegment.hasMotion ? 'Yes' : 'No';
            motionStatusEl.className = currentSegment.hasMotion ? 'motion' : 'no-motion';
        }
    }
}

// Find current segment based on video current time
function updateCurrentSegment() {
    if (!video || !playlistSegments.length) return;
    
    const currentTime = video.currentTime;
    let segmentTime = 0;
    let newIndex = -1;
    
    // Calculate which segment should be playing based on cumulative duration
    for (let i = 0; i < playlistSegments.length; i++) {
        // Assume each segment is roughly the same duration (we could parse this from EXTINF if needed)
        const segmentDuration = 30; // Default duration, could be made more precise
        if (currentTime >= segmentTime && currentTime < segmentTime + segmentDuration) {
            newIndex = i;
            break;
        }
        segmentTime += segmentDuration;
    }
    
    if (newIndex !== currentSegmentIndex) {
        currentSegmentIndex = newIndex;
        updateStreamInfo();
    }
}

function initializePlayer() {
    if (Hls.isSupported()) {
        hls = new Hls({
            debug: false,
            enableWorker: true,
            liveSyncDurationCount: 3, // Adjust for live stream latency
            liveMaxLatencyDurationCount: 10,
            maxBufferLength: 30,
            maxMaxBufferLength: 600,
            maxBufferSize: 60 * 1000 * 1000, // 60MB
            maxBufferHole: 0.5,
            // Enable low latency mode
            lowLatencyMode: true,
            backBufferLength: 90,
            // Custom loader to ensure proper relative URL resolution
            loader: Hls.DefaultConfig.loader
        });

        hls.loadSource(playlistUrl);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, function() {
            statusEl.textContent = 'Ready to play';
            
            // Fetch and parse the playlist to extract metadata
            fetch(playlistUrl)
                .then(response => response.text())
                .then(playlistText => {
                    playlistSegments = parsePlaylistMetadata(playlistText);
                    updateStreamInfo();
                })
                .catch(err => {
                    console.warn('Failed to fetch playlist for metadata:', err);
                });
        });

        hls.on(Hls.Events.ERROR, function(event, data) {
            console.error('HLS Error:', data);
            if (data.fatal) {
                switch (data.type) {
                    case Hls.ErrorTypes.NETWORK_ERROR:
                        statusEl.textContent = 'Network error - retrying...';
                        hls.startLoad();
                        break;
                    case Hls.ErrorTypes.MEDIA_ERROR:
                        statusEl.textContent = 'Media error - recovering...';
                        hls.recoverMediaError();
                        break;
                    default:
                        statusEl.textContent = 'Fatal error - cannot recover';
                        hls.destroy();
                        break;
                }
            }
        });

        hls.on(Hls.Events.FRAG_LOADED, function() {
            if (statusEl.textContent === 'Loading...' || statusEl.textContent === 'Initializing...') {
                statusEl.textContent = 'Streaming';
            }
        });

    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (Safari)
        video.src = playlistUrl;
        statusEl.textContent = 'Ready to play (native)';
    } else {
        statusEl.textContent = 'HLS not supported in this browser';
        console.error('HLS is not supported');
    }
}

// Video event listeners
video.addEventListener('loadstart', () => statusEl.textContent = 'Loading...');
video.addEventListener('waiting', () => statusEl.textContent = 'Buffering...');
video.addEventListener('playing', () => statusEl.textContent = 'Playing');
video.addEventListener('pause', () => statusEl.textContent = 'Paused');
video.addEventListener('ended', () => statusEl.textContent = 'Ended');

// Track current segment during playback
video.addEventListener('timeupdate', updateCurrentSegment);

// Initialize the player when page loads
document.addEventListener('DOMContentLoaded', initializePlayer);

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (hls) {
        hls.destroy();
    }
});

// Format timestamps for display
function formatTimestamp(isoString) {
    return new Date(isoString).toLocaleString();
}

document.getElementById('startTime').textContent = formatTimestamp('{{.StartTime}}');
document.getElementById('refTime').textContent = formatTimestamp('{{.RefTime}}');
</script>
{{end}}
